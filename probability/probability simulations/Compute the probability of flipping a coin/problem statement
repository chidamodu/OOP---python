a) Simulate flipping a coin N times.

b) Look at a subset N1≤N of the experiments in a) and compute the probability of getting a head (M1/N1, where M1 is the number of heads in N1 experiments). 
Choose N=1000 and print out the probability for N1=10,100,500,1000. Generate just N numbers once in the program. How do you think the accuracy of the computed 
probability vary with N1? Is the output compatible with this expectation?

c) Now we want to study the probability of getting a head, p, as a function of N1, i.e., for N1=1,…,N. 

d) An array q[i] = np.sum(h([:i])) reflects a cumulative sum and can be efficiently generated by np.cumsum: q = np.cumsum(h). Thereafter we can compute p by q/I, 
where I[i]=i+1 and I can be computed by np.arange(1,N+1) or r_[1:N+1] (integers 1, 2, …, up to but not including N+1). Use cumsum to make an alternative 
vectorized version of the function in c).

e) Write a test function that verifies that the implementations in c) and d) give the same results.

f) Make a function that applies the time module to measure the relative efficiency of the implementations in c) and d).

g) Plot p against I for the case where N=10000. Annotate the axis and the plot with relevant text.



